/*
ЮФУ, ИКТИБ, МОП ЭВМ
Объектно-ориентированное программирование
КТбо2-6, Миронов Егор Сергеевич
Лабораторная работа №1
08.09.2024
*/

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <vld.h>

using namespace std;

class Parking; // Раннее объявления класса для видимости в классе Car

class Car {
private:
    string number{}, make{}, colour{}; //  Номер, марка, цвет автомобиля
public:
    Car(string number, string make, string colour) {
        this->number = number;
        this->make = make;
        this->colour = colour;
    }

    void parking(Parking& parkingLot);

    void leave(Parking& parkingLot);

    friend void printParkedCars(Parking& parkingLot);

    friend void isParked(Car* car, Parking& parkingLot);

    ~Car() {};
};

class Parking {
public:
    vector<pair<Car*, bool>> cars{10};

    ~Parking() {};
};

//  Метод для парковки авто
void Car::parking(Parking& parkingLot) {
    //  Поиск машины с определенным номером, чтобы изменить метку присутствия на парковке
    auto it = find_if(parkingLot.cars.begin(), parkingLot.cars.end(),
        [this](const pair<Car*, bool>& carPair) {
            return carPair.first != nullptr && carPair.first->number == this->number; // Проверка на nullptr
        });

    if (it == parkingLot.cars.end()) {
        int flag = 0;
        for (int i = 0; i < 10; i++) {
            if (parkingLot.cars[i].first == nullptr) {
                parkingLot.cars[i].first = this;
                parkingLot.cars[i].second = true;
                flag = 1;
                cout << "Car with number " << this->number << " parked" << endl;
                break;
            }
        }
        if (!flag) {
            parkingLot.cars.push_back(make_pair(this, true));
        }
    }
    else {
        parkingLot.cars[it - parkingLot.cars.begin()].second = true;
    }
}

//  Метод для выезда авто с парковки
void Car::leave(Parking& parkingLot) {
    auto it = find_if(parkingLot.cars.begin(), parkingLot.cars.end(),
        [this](const pair<Car*, bool>& carPair) {
            return carPair.first->number == this->number;
        });  //  Поиск машины с определенным номером, для того поменять метку присутствия на парковке
    
    if (it != parkingLot.cars.end()) {
        cout << "Car with number " << this->number << " leaved parking" << endl;
        parkingLot.cars[it - parkingLot.cars.begin()].second = false;
    }
}

//  Дружественная функция для проверки присутствия авто на стоянке
void isParked(Car* car, Parking& parkingLot) {
    auto it = find_if(parkingLot.cars.begin(), parkingLot.cars.end(),
        [car](const pair<Car*, bool>& carPair) {
            return carPair.first->number == car->number;
        }); //  Поиск машины с определенным номером
    if (it != parkingLot.cars.end()) {
        cout << "Car with number " << car->number << " is parked" << endl << endl;
    }
    else {
        cout << "Car with number " << car->number << " is not parked" << endl << endl;
    }
}

//  Дружественная функция для вывода всех припаркованных машин
void printParkedCars(Parking &parkingLot) {
    int flag = 0;
    for (int i = 0; i < parkingLot.cars.size(); i++) {
        if (parkingLot.cars[i].second) {
            if (!flag) {
                cout << "Parked cars:" << endl;
                flag = 1;
            }
            cout << "Number: " << parkingLot.cars[i].first->number << endl;
            cout << "Make: " << parkingLot.cars[i].first->make << endl;
            cout << "Color: " << parkingLot.cars[i].first->colour << endl;
        }
        cout << endl;
    }
}

int main() {
    Parking parkingLot{};

    //  Создаем объекты класса Car и указатели на них
    Car car1("A126AA_26", "BMW", "blue");
    Car* ptrcar1 = &car1;
    Car car2("E707KA_23", "Nissan", "grey");
    Car* ptrcar2 = &car2;
    Car car3("A005AA_05", "Lada", "black");
    Car* ptrcar3 = &car3;
    Car car4("T777TT_777", "Ferrari", "red");
    Car* ptrcar4 = &car4;
    Car car5("T136AT_126", "Mercedes-Benz", "black");
    Car* ptrcar5 = &car5;
    Car car6("O777OO_123", "Toyota", "purple");
    Car* ptrcar6 = &car6;
    Car car7("E025EA_05", "Suzuki", "yellow");
    Car* ptrcar7 = &car7;
    Car car8("H7117TH_09", "Land Lover", "pink");
    Car* ptrcar8 = &car8;
    Car car9("K005BB_25", "Jaguar", "green");
    Car* ptrcar9 = &car9;
    Car car10("T100PP_07", "Audi", "white");
    Car* ptrcar10 = &car10;
    Car car11("T777TT_77", "Audi", "white");
    Car* ptrcar11 = &car11;

    //  Паркуем автомобили
    car1.parking(parkingLot);
    car2.parking(parkingLot);
    car3.parking(parkingLot);
    car4.parking(parkingLot);
    car5.parking(parkingLot);
    car6.parking(parkingLot);
    car7.parking(parkingLot);
    car8.parking(parkingLot);
    car9.parking(parkingLot);
    car10.parking(parkingLot);
    car11.parking(parkingLot);

    //  Проверяем присутствие авто на парковке
    isParked(ptrcar7, parkingLot);
    isParked(ptrcar1, parkingLot);

    //  Выезд авто с парковки
    car1.leave(parkingLot);
    car3.leave(parkingLot);
    car5.leave(parkingLot);

    //  Выводим список припаркованных автомобилей
    printParkedCars(parkingLot);

    return 0;
}
